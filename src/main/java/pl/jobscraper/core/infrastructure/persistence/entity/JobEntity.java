package pl.jobscraper.core.infrastructure.persistence.entity;

import jakarta.persistence.*;
import pl.jobscraper.core.domain.model.JobState;
import pl.jobscraper.core.domain.model.value.EmploymentType;
import pl.jobscraper.core.domain.model.value.Seniority;

import java.time.Instant;
import java.util.List;
import java.util.UUID;

/**
 * JPA Entity mapping to 'jobs' table.
 * <p>
 * This is a persistence layer entity representing a job posting in the database.
 * It is NOT the domain model - see {@link pl.jobscraper.core.domain.model.Job}
 * for the business object.
 *
 * <p><strong>Key differences from domain Job:</strong>
 * <ul>
 *   <li>Contains technical fields: id (UUID), state, timestamps</li>
 *   <li>Has JPA annotations (@Entity, @Table, @Column)</li>
 *   <li>Mutable (has setters) - required by JPA/Hibernate</li>
 *   <li>Default constructor (required by JPA)</li>
 * </ul>
 *
 * <p><strong>State management:</strong>
 * The 'state' field (NEW/CONSUMED/STALE) is a technical concern managed
 * by the persistence layer, not business logic. Domain model Job does not
 * have a state field.
 *
 * <p><strong>Identity (XOR constraint):</strong>
 * Exactly one of canonicalUrl or fallbackHash must be non-null.
 * This is enforced by database constraint (chk_identity_xor).
 *
 * <p><strong>Immutability note:</strong>
 * Unlike domain Job, this entity is mutable. JPA requires setters
 * for field population after SELECT queries.
 *
 * @see pl.jobscraper.core.domain.model.Job
 * @see JobState
 */
@Entity
@Table(name = "jobs")
public class JobEntity {

    /**
     * Primary key - UUID generated by database.
     * <p>
     * Database uses gen_random_uuid() to generate UUIDs.
     * JPA reads the generated value after insert.
     */
    @Id
    @Column(name = "id", updatable = false, nullable = false)
    private UUID id;

    /**
     * Job title (required).
     */
    @Column(name = "title", nullable = false, length = 500)
    private String title;

    /**
     * Company name (required).
     */
    @Column(name = "company", nullable = false, length = 255)
    private String company;

    /**
     * Job location (required).
     */
    @Column(name = "location", nullable = false, length = 255)
    private String location;

    /**
     * Job posting URL (required).
     */
    @Column(name = "url", nullable = false, columnDefinition = "TEXT")
    private String url;

    /**
     * When job was published (required).
     */
    @Column(name = "published_date", nullable = false)
    private Instant publishedDate;

    /**
     * Job board/source name (optional).
     */
    @Column(name = "source", length = 100)
    private String source;

    /**
     * Seniority level (optional).
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "seniority", length = 50)
    private Seniority seniority;

    /**
     * Employment type (optional).
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "employment_type", length = 50)
    private EmploymentType employmentType;

    /**
     * Technology keywords (optional).
     * <p>
     * PostgreSQL array type (TEXT[]).
     */
    @Column(name = "tech_keywords", columnDefinition = "TEXT[]")
    private List<String> techKeywords;

    /**
     * Salary information (optional).
     */
    @Column(name = "salary", length = 255)
    private String salary;

    /**
     * Job description snippet (optional).
     */
    @Column(name = "description_snippet", columnDefinition = "TEXT")
    private String descriptionSnippet;

    /**
     * Canonical URL (identity method 1).
     * <p>
     * XOR constraint with fallbackHash - exactly one must be non-null.
     * Used when job URL is valid and can be canonicalized.
     */
    @Column(name = "canonical_url", columnDefinition = "TEXT")
    private String canonicalUrl;

    /**
     * SHA-256 hash fallback (identity method 2).
     * <p>
     * XOR constraint with canonicalUrl - exactly one must be non-null.
     * Used when job URL is invalid/missing.x`
     * Format: 64 hexadecimal characters (lowercase).
     */
    @Column(name = "fallback_hash", length = 64)
    private String fallbackHash;

    /**
     * Job lifecycle state.
     * <p>
     * Possible values: NEW, CONSUMED, STALE.
     * Default: NEW (set by database).
     *
     * @see JobState
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "state", nullable = false, length = 20)
    private JobState state;

    /**
     * When record was created (never updated).
     */
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    /**
     * When record was last updated.
     */
    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;

    /**
     * When state last changed.
     */
    @Column(name = "state_changed_at", nullable = false)
    private Instant stateChangedAt;

    /**
     * When job entered NEW state (null for non-NEW jobs).
     * <p>
     * Used for:
     * <ul>
     *   <li>Queue sorting (oldest NEW first)</li>
     *   <li>TTL calculation (7 days from this timestamp)</li>
     * </ul>
     */
    @Column(name = "entered_new_at")
    private Instant enteredNewAt;

    /**
     * Default constructor (required by JPA).
     * <p>
     * JPA/Hibernate needs a no-arg constructor to instantiate entities
     * when loading from database. Should not be used directly in code.
     */
    protected JobEntity() {
        // Required by JPA
    }


    public UUID getId() {
        return id;
    }

    public void setId(UUID id) {
        this.id = id;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getCompany() {
        return company;
    }

    public void setCompany(String company) {
        this.company = company;
    }

    public String getLocation() {
        return location;
    }

    public void setLocation(String location) {
        this.location = location;
    }

    public String getUrl() {
        return url;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public Instant getPublishedDate() {
        return publishedDate;
    }

    public void setPublishedDate(Instant publishedDate) {
        this.publishedDate = publishedDate;
    }

    public String getSource() {
        return source;
    }

    public void setSource(String source) {
        this.source = source;
    }

    public Seniority getSeniority() {
        return seniority;
    }

    public void setSeniority(Seniority seniority) {
        this.seniority = seniority;
    }

    public EmploymentType getEmploymentType() {
        return employmentType;
    }

    public void setEmploymentType(EmploymentType employmentType) {
        this.employmentType = employmentType;
    }

    public List<String> getTechKeywords() {
        return techKeywords;
    }

    public void setTechKeywords(List<String> techKeywords) {
        this.techKeywords = techKeywords;
    }

    public String getSalary() {
        return salary;
    }

    public void setSalary(String salary) {
        this.salary = salary;
    }

    public String getDescriptionSnippet() {
        return descriptionSnippet;
    }

    public void setDescriptionSnippet(String descriptionSnippet) {
        this.descriptionSnippet = descriptionSnippet;
    }

    public String getCanonicalUrl() {
        return canonicalUrl;
    }

    public void setCanonicalUrl(String canonicalUrl) {
        this.canonicalUrl = canonicalUrl;
    }

    public String getFallbackHash() {
        return fallbackHash;
    }

    public void setFallbackHash(String fallbackHash) {
        this.fallbackHash = fallbackHash;
    }

    public JobState getState() {
        return state;
    }

    public void setState(JobState state) {
        this.state = state;
    }

    public Instant getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(Instant createdAt) {
        this.createdAt = createdAt;
    }

    public Instant getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(Instant updatedAt) {
        this.updatedAt = updatedAt;
    }

    public Instant getStateChangedAt() {
        return stateChangedAt;
    }

    public void setStateChangedAt(Instant stateChangedAt) {
        this.stateChangedAt = stateChangedAt;
    }

    public Instant getEnteredNewAt() {
        return enteredNewAt;
    }

    public void setEnteredNewAt(Instant enteredNewAt) {
        this.enteredNewAt = enteredNewAt;
    }
}
